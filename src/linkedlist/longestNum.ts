function longestLine(mat: number[][]): number {
    let m = mat.length
    let n = mat[0].length
    let dp: number[][][] = Array(m).fill(0).map((x) => {
        return Array(n).fill(0).map(
            y => {
                return Array(4).fill(0)
            }
        )
    })
    let res = 0
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (mat[i][j] == 0) {
                for (let k = 0; k < 4; k++) {
                    dp[i][j][k] = 0
                }
            } else {
                dp[i][j][0] = j - 1 >= 0 ? dp[i][j - 1][0] + 1 : 1
                dp[i][j][1] = i - 1 >= 0 ? dp[i - 1][j][1] + 1 : 1
                dp[i][j][2] = i - 1 >= 0 && j - 1 >= 0 ? dp[i - 1][j - 1][2] + 1 : 1
                dp[i][j][3] = i - 1 >= 0 && j + 1 < n ? dp[i - 1][j + 1][3] + 1 : 1
                res = Math.max(res, Math.max(...dp[i][j]))
            }
        }
    }
    return res
}
let mat = [[1,1,1,1],[0,1,1,0],[0,0,0,1]]
console.log(longestLine(mat))
/*
*

### 问题描述

给定一个 `m x n` 的二进制矩阵 `mat`，返回矩阵中最长的连续 `1` 线段的长度。这条线段可以是水平的、垂直的、对角线的或反对角线的。

**示例:**
输入: `mat = [[0,1,1,0],[0,1,1,0],[0,0,0,1]]`
输出: `3`
解释: 在这个矩阵中，最长的连续 `1` 是对角线方向的，长度为 3。

### 解题思路：动态规划 (Dynamic Programming)

这道题最经典和高效的解法是使用动态规划。由于我们需要考虑四个方向，一个直接的想法是为每个方向都维护一个DP数组。

但是，更巧妙的方法是使用一个三维的DP数组 `dp[i][j][k]`，其中：

*   `i` 和 `j` 代表矩阵中单元格的坐标 `(i, j)`。
*   `k` 代表方向，`k` 可以是 0, 1, 2, 3，分别代表：
    *   `k = 0`: 水平 (Horizontal)
    *   `k = 1`: 垂直 (Vertical)
    *   `k = 2`: 对角线 (Diagonal, 左上到右下)
    *   `k = 3`: 反对角线 (Anti-diagonal, 右上到左下)

`dp[i][j][k]` 的含义是：**在矩阵 `(i, j)` 位置结束的、方向为 `k` 的连续 `1` 的长度**。

#### 状态转移方程

我们遍历矩阵中的每一个单元格 `mat[i][j]`。

1.  **如果 `mat[i][j] == 0`**:
    *   那么在 `(i, j)` 这个位置结束的任何方向的连续 `1` 的长度都必须是 `0`。
    *   所以 `dp[i][j][0] = dp[i][j][1] = dp[i][j][2] = dp[i][j][3] = 0`。

2.  **如果 `mat[i][j] == 1`**:
    *   我们需要根据前一个单元格的DP值来计算当前值。
    *   **水平 (k=0)**: 当前的水平连续 `1` 是由左边的单元格 `(i, j-1)` 延伸过来的。
        *   `dp[i][j][0] = dp[i][j-1][0] + 1`
    *   **垂直 (k=1)**: 当前的垂直连续 `1` 是由上边的单元格 `(i-1, j)` 延伸过来的。
        *   `dp[i][j][1] = dp[i-1][j][1] + 1`
    *   **对角线 (k=2)**: 当前的对角线连续 `1` 是由左上方的单元格 `(i-1, j-1)` 延伸过来的。
        *   `dp[i][j][2] = dp[i-1][j-1][2] + 1`
    *   **反对角线 (k=3)**: 当前的反对角线连续 `1` 是由右上方的单元格 `(i-1, j+1)` 延伸过来的。
        *   `dp[i][j][3] = dp[i-1][j+1][3] + 1`

在计算每个 `dp[i][j][k]` 的值时，都需要注意边界条件（比如 `j-1`, `i-1`, `j+1` 是否越界）。如果越界，说明没有前一个单元格，长度就是 `1`。

#### 算法流程

1.  获取矩阵的维度 `m` 和 `n`。
2.  创建一个 `dp` 数组 `dp[m][n][4]` 并初始化为 0。
3.  初始化一个全局最大长度变量 `max_len = 0`。
4.  使用两层循环遍历矩阵中的每个单元格 `(i, j)` 从 `(0, 0)` 到 `(m-1, n-1)`。
5.  在循环中，如果 `mat[i][j] == 1`，则根据上面的状态转移方程计算 `dp[i][j][k]` 的四个值。
6.  每计算出一个 `dp[i][j][k]` 的值，就用它来更新 `max_len`。
7.  遍历结束后，`max_len` 就是最终的答案。

#### 空间优化

你会发现，计算 `dp[i][j]` 的值只依赖于第 `i` 行和第 `i-1` 行的数据。因此，可以进行空间优化，将三维的 `dp` 数组压缩到二维，只用 `dp[j][k]` 来存储当前行的信息，从而将空间复杂度从 O(m\*n) 降低到 O(n)。

*   **水平方向**：`dp[j][0]` 依赖于 `dp[j-1][0]`，可以在当前行内解决。
*   **其他三个方向**：`dp[j][1]`, `dp[j][2]`, `dp[j][3]` 都依赖于上一行的信息，所以在计算新一行的值之前，需要先保存上一行的状态。

这种动态规划的解法，时间复杂度为 **O(m \* n)**，因为需要遍历矩阵中的每个单元格一次。空间复杂度优化后为 **O(n)**。和一维问题一样，这也是最优的时间复杂度，因为你必须检查每个单元格才能得出结论。
* */